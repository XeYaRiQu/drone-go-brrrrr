%% Declare Parameters - Cross Configuration based on Inertial Measurement Unit (IMU)
G = 9.81 ;      % m/s^2 (Gravitational Field Strength)
M = 0.468 ;    %kg (Mass of Drone)
L = 0.330    ;  %m (Length of Drone)
Jr = 3.357 * 10^-5 ;  % kg m^2 (Inertia Constant) 
kt = 2.980 * 10^-6 ;  % Thrust Coefficient
kb = 1.140 * 10^-7 ; % Drag Coefficient
l = 0.150 ;  % metres - This is the distance between the rotor and the center of mass of the quadcopter
Ixx = 4.856 * 10^-3 ;%Inertia for x along the horizontal axis
Iyy = 4.856 * 10^-3 ;% kg m^2
Izz = 8.801* 10^-3 ;%kg m^2 
kdx = 0.25 ; %Is this air resistance under the X axis?
kdy = 0.25 ; %Is this air resistance under the Y axis?
kdz = 0.25 ; %Is this air resistance under the Z axis?
phi = 0;
theta = 0;
psi = 0;
kp = 0.35; %Proportional Gain Parameter for PID Control
ki = 0.20 ; % Integral Gain Parameter for PID Control
kd = 0.75 ; % Derivative Gain Parameter for PID Control



%Inertial Frame Reference position
x = 5;
y = 6;
z = 7;
%%
%Body Frame Reference
u = 20;
v = 30;
w = 40;

%P,Q,R - Angular velocity in Body Frame
p = 0;
q= 0;
r = 0;

% Equation 2 
 %Orientation of a rigid body can be achieved by combination of three Euler Angles 
 % Rx Ry Rz = Rotation matrices of X Y and Z axis
 %R = rotation matrix depicting relationship between inertial frame and
 %body frame - this is a body to inertial frame

 Rx = [ 1 0 0 ; 0 cos(phi) -sin(phi); 0 sin(phi) cos(phi)];
 Ry = [cos(theta) 0 sin(theta);0 1 0 ; -sin(theta) 0 cos(theta)];
 Rz = [cos(psi) -sin(psi) 0 ; sin(psi) cos(psi) 0 ; 0 0 1];
 R = Rz * Ry *Rx ;

% Equation 3
% Reference Frame Transformation
%Linear Velocity = Speed in a straight line (measured in m/s)
%Angular Velocity = Change in the angle over time (measured in rad/s) -
%this can also be converted into degrees also

%Linear velocity in Inertial Frame
inertial_axis_frame = [x; y; z];

%Angular Velocity in Inertial Frame
inertial_angle_frame = [phi ; theta ; psi];

%Linear Velocity in Body Frame
body_axis_frame = [u ; v ; w];

%Angular Velocity in Body Frame
body_angle_frame = [p; q; r];
% Set 2

%Define Position Vectors
% v_linear = R. Vb - dot product of R and VB
v_inertial_frame = R*body_axis_frame;

% Angular Velocity of n
Wn = [ 1    0                              -sin(theta);
            0    cos(phi)                   -sin(phi);
            0     sin(phi)/cos(theta)   cos(phi)/cos(theta)];

% Angular Velocity of Inertial Frame
W_inertial_frame = inv(Wn) * [body_angle_frame] ;
%Wb = dot(Wn, W_inertial_frame);
%% Page 6 of Paper
%Inertia Matrix - Equation 9 
%Asumming same structure on the symmetrical = equal weight
total_inertia = [Ixx 0      0;
                          0    Iyy  0;
                          0     0      Izz];

%Angular Velocity of the 4 Rotors
%Motor 1 and 3 are chosen to be on the roll axis
%Motor 2 and 4 are chosen to be on the pitch axis
%i = 1 and i = 3 supposed to be on the clockwise direction
%i = 1:4;
w1 =10 ;%Radians/second 
w2 = 20; %Radians/ Second
w3 = 30; %Radians / Second
w4 = 40; % Radians/ Second
%Rotational Motion - Assuming rigid body and Euler equation for rigid
%Declare for External Torque tphi ttheta tpsi
%tphi = roll torque component
%ttheta = pitch torque component
%tpsi = total torque around the yaw axis = rotor axis is pointing in the
%z-direction in the body frame 
%tau = torque moment
tau_phi = l*kt*(-(w2)^2+(w4)^2);
tau_theta = l*kt*(-(w1)^2+(w3)^2);
%Total torque about the z-axis is given by the sum of all the torques from
%each propeller as follows:
tau_psi = kb*( +(w2)^2+(w4)^2-(w1)^2-(w3)^2);

%External Torque Tb = sum of all the total torque - Equation 16
tau_b = [tau_phi ; tau_theta; tau_psi];

%bodies, dynamics equation in the body frame
% Assuming total_inertia is a matrix and body_angle_frame, tau_b are vectors
inv_total_inertia = inv(total_inertia);
result = inv_total_inertia * (-(total_inertia * body_angle_frame) + tau_b);

%Total angular velocity of all 4 rotors;
Wr = -w1 +w2-w3+w4; 

%Gyroscopic Forces = caused by the combined rotation of the four rotors and
%The quadopter body
%Gyroscopic torque is generated by the rotors of the drone as a result of
%rotation about the inertial coordinates axis and the axis rotating at the
%angular rate of the quadrotor - reference from Joey End

%Parameters Translational Motion - Newtonian Equation to model the linear dynamics
%Newtonian Equation of Motion 
%Fd = Drag Force
%Tb = Thrust Moment for the entire moment of the body frame?
%Drag Force Fd I guess can be used with relevance to the air resistance
Fd = - (kdx+kdy+kdz) *v_inertial_frame ;
thrust = kt *((w1)^2 + (w2)^2 + (w3)^2 +(w4)^2); 

% Thrust of B acting in the Z-Axis
thrust_b =  [ 0 ; 0 ; thrust];

%Translation Motion - Using Newtonian Equation to model the linear dynamics
%Extraneous forces acting on the Quadcopter - Equation 17
mv1= [0;0;-M*G] + (R*thrust_b) + Fd ;

%Skipping from Equation 20 onwards 
% This is the direct equation 
%Solving for Angular Velocities of the rotor

% Linear Acceleration in Inertial Frame (Not needed in this equation)
%x_doubledot = (thrust / M) * (cos(phi)*sin(theta)*cos(phi) + sin(psi)*sin(phi));
%y_doubledot = (thrust/M) * (sin(psi)*sin(theta)*cos(phi)+ cos(psi)*sin(phi));
%z_doubledot = -G + (thrust/M)*(cos(theta)*cos(phi));
%linear_acceleration_inertial_frame = [x_doubledot y_doubledot z_doubledot];

%General form of PID Controller
%Quadcopter System Stabilization

% create Equation 23
%e(t) - error state
% r(t) = desired state
%y(t) = current/ actual state
%u(t) = control input needed for state
%syms e(t) r(t) y(t) u(t)

%e(t) = r(t) - y(t);
%u(t) = kp*e(t) + ki 

%Equation 26 - last set before PID
angular_velocity_all_rotors = [(w1)^2 ; (w2)^2; (w3)^2 ; (w4)^2];
length_thrust_drag_matrix = [kt       kt       kt      kt ;
                                                 0       -l*kt   0      l*kt;
                                                 -l*kt   0       l*kt  0;
                                                 -kb     kb     -kb    kb;];
angular_velocity_tau_with_thrust = [ thrust; tau_phi ; tau_theta ; tau_psi;];

angular_velocity_all_rotors = inv(length_thrust_drag_matrix) * angular_velocity_tau_with_thrust;




